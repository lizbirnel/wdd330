<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Week 10 Notes | BYU-I WDD 330</title>
    <link rel="stylesheet" href="../css/styles.css" />
  </head>
  <body>
    <header>
      <h1>Week 10 Notes</h1>
    </header>
    <main>
      <!-- <p>
      See console for many examples of experimenting with the concepts and code
      this week.
    </p> -->
      <h2>MDN: Validating Forms</h2>
      <section>
        <h3>Client-side form validation</h3>
        <p>
          - Before submitting data to the server backend, use client-side
          validation to ensure data requirements are met
        </p>
        <p>
          - Client-side is initial check and important for good UX design,
          allows for user to fix right away
        </p>
        <p>
          - If it gets to server and is rejected, that can cause noticeable
          delay with the processing to the server and back to the user
        </p>
        <p>
          - Client-side validation is not an exhaustive security measureâ€”always
          use server-side validation as well as client-side! Client-side is easy
          to bypass and hack
        </p>
        <p>
          - Form validation is to help get the right data in right format,
          protect users' data, and protect ourselves
        </p>
        <p>
          - 2 types of client-side validation: Built-in validation (uses HTML5
          form validation) and JS validation (completely customizeable, but you
          need to create it)
        </p>
        <h3>Built-in form validation</h3>
        <p>- Ability to validate most user data without JS</p>
        <p>
          - Required-specifies which fields need to be filled out to submit the
          form
        </p>
        <p>- minlength/maxlength min and max length of strings</p>
        <p>
          - min and max- specifies the min and max values fo numerical input
          types
        </p>
        <p>- type- which type data needs to be (number, email address, etc)</p>
        <p>
          - pattern- regular expression that defines a pattern for entered data
          to follow
        </p>
        <p>
          - If data meets all of the rules specified, it is considered valid. If
          not, it's invalid
        </p>
        <p>
          - If valid, element matches :valid CSS pseudo-class, so you can style
          valid elements. If user tries to send data, browser will submit the
          form.
        </p>
        <p>
          - If invalid, element matches :invalid pseudo-class so you can style
          invalid elements. Form will be blocked from submitting with error
          message
        </p>

        <h3>Validating against regular expression</h3>
        <p>
          - Pattern attribute- expects a regular expression as its value (regex)
        </p>
        <p>
          - regex patterns are used to match character combinations in text
          strings (ideal for form validation and serve other variety of uses in
          JS)
        </p>
        <p>
          - Regex patterns are complex! Some basic examples are: <br />a: match
          one character that is a(ntot b, not aa, etc)<br />abc: matches a,
          followed by b, followed by c<br />ab?c: matches a, optionally followed
          by b, followed by c. (ac or abc)<br />ab*c: matches a, optionally
          followed by any number of b's, followed by c (ac, abc, abbbbbbbc,
          etc)<br />a|b: matches one character that is a or b<br />abc|xyz:
          matches exactly abc or exactly xyz (not abcxyz or a or y, etc.)
        </p>

        <a
          class="notesLink"
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"
          >More Regular Expression Info</a
        >
        <p>...</p>

        <a class="notesLink" href="form-validation.html"
          >Favorite Fruit Form Validation Example</a
        >
        <h3>Constraining length</h3>
        <p>
          - you can constrain length of text fields using minlength and
          maxlength attributes
        </p>
        <p>
          - Browsers often don't allow user to type a longer than expected value
          in fields
        </p>
        <p>
          - better UX design is to provide character count feedback in an
          accessible manner
        </p>
        <h3>Constraining value of entries</h3>
        <p>
          - number fields: use min and max attributes to provide a range of
          acceptable values
        </p>
        <h3>Validating forms using JavaScript</h3>
        <p>
          - must use JavaScript if you want to customize look and feel of error
          messages
        </p>
        <p>
          - Constraint Validation API: consists of set of methods and properties
          (button, fieldset, input, output, select, and textarea elements.
        </p>
        <p>
          - validationMessage: returns localized message about constraints not
          met
        </p>
        <p>
          - validity: Returns ValidityState object that tells various issues
          like patternmismatch, tooLong or tooShort, rangeOverflow or
          rangeUnderflow, typeMismatch, valid, and valueMissing
        </p>
        <p>
          - willValidate: returns true if element will be validated when
          submitted, false if not
        </p>
        <p>
          - Implementing a customized error message is a common case of
          constraint validation API.
        </p>

        <a class="notesLink" href="form-validation-3.html"
          >Custom Error Message Example</a
        >
        <p>...</p>

        <a class="notesLink" href="form-validation-4.html"
          >Another Custom Error Message Example</a
        >

        <h2>MDN: Using Fetch</h2>
        <h3>Fetch API</h3>
        <p>
          - The Fetch API provides JavaScript interface for accessing a
          manipulating requests and responses. Provides global fetch() method to
          provide easy, logical way to fetch resources across network
        </p>
        <p>
          - Fetch provids single logical place to define HTTP related concepts
          like CORS and extensions to HTTP
        </p>
        <p>
          - Fetch specification differs from jQuery.ajax(): Promise returned
          from fetch() won't reject on HTTP error status. As soon as server
          responds with headers, Promise will resolve normally
        </p>
        <p>
          - fetch() won't send cross-origin cookies unless you set them in init
          option.
        </p>
        <p>
          - simplest use o fetch() takes one argument of the path to the
          resource you want and returns a promise containing the response
        </p>
        <p>
          - if you want the actual JSON, you must use json() method to extrat
          the data/content fromt the promise response
        </p>
        <p>
          To cause browsers to send a request with credentials included on both
          same-origin and cross-origin, use credentials: 'include' to the init
          object you pass
        </p>
        <p>`fetch('https://example.com', { credentials: 'include' });`</p>
        <p>- to not use credentials in request, use credentials: 'omit'</p>
        <p>- use fetch() to POST JSON-encoded data</p>
        <p>
          - files can be uploaded using an HTML type="file" input element,
          FormData() and fetch()
        </p>
        <p>- can upload multiple files by adding multiple as attribute</p>
        <h3>Checking for success</h3>
        <p>
          - a fetch() promise will reject with an error. An accurate check for
          successful fetch() would check for promise resolved, then check that
          Response.ok property is true.
        </p>
        <h3>Supply your own request object</h3>
        <p>
          - you can create a request object using Request() constructor and pass
          in as a fetch() method argument
        </p>
        <p>Request() accepts same parameters as fetch()</p>
        <h3>Headers</h3>
        <p>
          - Headers interface allows you to create your own headers object with
          Headers() constructor.
        </p>
        <p>- Headers object is a simple multimap of names to values</p>
        <p>- Contents can be queried and retrieved</p>
        <p>
          - Good use case for headers is checking whether content type is
          correct before processing further
        </p>
        <h3>Guard</h3>
        <p>
          - Headers' objects have a guard property because they can be sent in
          requests and received in responses and have limitations
        </p>
        <p>
          - Guard affects which mutation operations are allowed on headers
          object
        </p>
        <p>
          - possible guard values include none, request, request-no-cors,
          response, and immutable
        </p>
        <h3>Response objects</h3>
        <p>
          - most common response properties are Response.status (default value
          200, but an integer), Response.statusText (a string with default of
          ""), and Response.ok (shorthand for checking status in range 200-299
          and returns Boolean)
        </p>
        <p>
          - Response() constructor takes two optional arguments, body for the
          response and init object
        </p>

        <script></script>
      </section>
    </main>
    <footer>
      <p><a href="/index.html"> Elizabeth Birnel</a> | Utah | WDD 330 | BYUI</p>
    </footer>
  </body>
</html>
